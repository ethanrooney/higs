//Created by S. Henshaw 3/26/10
//Mostly Copied from geant4/examples/novice/NO2

#include "PrimaryGeneratorAction.hh"
#include "ExperimentConstruction.hh"

#include "TMath.h"
#include "G4Event.hh"
#include "G4Tubs.hh"
#include "G4ParticleGun.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "globals.hh"
#include "Randomize.hh"
#include "MoreUnits.hh"
#include "geomdefs.hh"
#include "G4VPhysicalVolume.hh"
#include "G4VSolid.hh"
#include "G4LogicalVolume.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

PrimaryGeneratorAction::PrimaryGeneratorAction(
                                               ExperimentConstruction* myDC)
:myDetector(myDC)
{
  G4int n_particle = 1;
  particleGun = new G4ParticleGun(n_particle);

// default particle

  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
  G4ParticleDefinition* particle = particleTable->FindParticle("gamma");
  //G4ParticleDefinition* particle = particleTable->FindParticle("neutron");
  particleGun->SetParticleDefinition(particle);


  
}
 

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

PrimaryGeneratorAction::~PrimaryGeneratorAction()
{
  delete particleGun;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void PrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent)
{ 
  //Setting Beam at -z of world and making point beam
  //SetZBeamStartofWorld(5.0*mm);
  //  SetZBeamStartofWorld(0.5*in);
  //SetZBeamStartofWorld(100*mm);

  //Setting Beam at 0,0,0 of world and making Isotropic Beam
  //SetIsoBeamCenterWorld();

  //Creating isotropic beam uniformly distributed within Target
  SetTargetBeamCenterWorld();

    
  //Should only generate 1 vertex
  particleGun->GeneratePrimaryVertex(anEvent);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void PrimaryGeneratorAction::SetZBeamStartofWorld(G4double BeamDiameter)
{
  
  if(BeamDiameter>=0.0)
    {
      particleGun->SetParticleEnergy(15.1*MeV);
      particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
      
      //Distributed particles over a circle
      if(BeamDiameter<0.001*mm)
	{//Just makes a point beam 
	  G4double position = -0.5*(myDetector->GetWorldLengthZ());
	  particleGun->SetParticlePosition(G4ThreeVector(0.*mm,0.*mm,position));
	}
      else
	{//Uniformly distributes particles in circle of diameter=BeamDiamter
	  G4bool flag=true;
	  G4double posX;
	  G4double posY;
	  G4double BeamRadius=BeamDiameter/2.0;
	  G4double radius=0;
	  while(flag)
	    {
	      //posX=BeamDiameter/2.0;
	      //	      posY=BeamDiameter/2.0;
	      posX=(2.*(G4UniformRand()-0.5))*BeamRadius;
	      posY=(2.*(G4UniformRand()-0.5))*BeamRadius;
	      radius=sqrt((posX*posX)+(posY*posY));
	      if(radius<=BeamRadius)
		flag=false;
	      //	      flag=false;
	    }
	  G4double posZ = -0.5*(myDetector->GetWorldLengthZ());
	  particleGun->SetParticlePosition(G4ThreeVector(posX,posY,posZ));
	  

	}
    }
  else
    {
      G4cerr<<"**ERROR:  BeamDiameter INVALID!!!!**"<<G4endl;
      G4Exception();
    }
}

void PrimaryGeneratorAction::SetIsoBeamCenterWorld(void)
{//Isotropic Beam in CosTheta and Phi at Center of World

  particleGun->SetParticlePosition(G4ThreeVector(0.*mm,0.*mm,0.0*mm));
  particleGun->SetParticleEnergy(15.1*MeV);

  G4ThreeVector v;
  G4double costheta = 2.*(G4UniformRand()-0.5);
  G4double theta = acos( costheta );
  G4double phi = 360.0*deg*G4UniformRand();
//  G4double phi = ((i==0)?0.0*deg:180.0*deg);
  v.setRThetaPhi(1,theta,phi);

  //v.set(0.0,0.0,1.0);

  particleGun->SetParticleMomentumDirection(v);

}


void PrimaryGeneratorAction::SetTargetBeamCenterWorld(void)
{//Isotropic Beam in CosTheta and Phi uniformly distributed within
 //Target Specifications given below.

  //Returns pointer to Target Solid Defined in ExperimentConstruction
  G4VPhysicalVolume* physiTarget=myDetector->GetTargetPhysicalVolume();
  G4VSolid* target=physiTarget->GetLogicalVolume()->GetSolid();
  G4RotationMatrix TargetRot=*physiTarget->GetRotation();
  G4ThreeVector TargetPos=physiTarget->GetTranslation();

  //Makes a Box big enough to enclose the Target for Gen. Inital guess (Assumes Target is cylinder)

  G4double GenBoxVol=target->GetCubicVolume();
  G4double GenBoxLength=2*pow(GenBoxVol,0.3333333);

  G4bool flag=true;
  G4ThreeVector pos;
  while(flag)
    {
      //Generating Random Position inside Gen Box 
      G4double xGen=GenBoxLength*(2.*(G4UniformRand()-0.5));
      G4double yGen=GenBoxLength*(2.*(G4UniformRand()-0.5));
      G4double zGen=GenBoxLength*(2.*(G4UniformRand()-0.5));
      pos=G4ThreeVector(xGen,yGen,zGen);

      //Checking to see if pos is inside target volume
      if(target->Inside(pos)==kInside)
	{
	  //	  G4cout<<"The primary is inside the Target"<<G4endl;
	  flag=false;
	}
   
    }
  G4ThreeVector posTrans=pos + TargetPos;
  G4ThreeVector posFinal=posTrans.transform(TargetRot);
    
  particleGun->SetParticlePosition(posFinal);
  particleGun->SetParticleEnergy(15.1*MeV);
  //particleGun->SetParticleEnergy(26*MeV);

  G4ThreeVector v;
  G4double costheta = 2.*(G4UniformRand()-0.5);
  G4double theta = acos( costheta );
  G4double phi = 360.0*deg*G4UniformRand();
  //  G4double phi = ((i==0)?0.0*deg:180.0*deg);
  v.setRThetaPhi(1,theta,phi);
  
  particleGun->SetParticleMomentumDirection(v);
  
}
